#  Dragonboat使用入门 #

本文档提供Dragonboat的使用入门信息，阅读完后您将可以自如的使用Dragonboat库在您的项目中实现您所需要的各类有强一致需求的功能与组件。本文档假设您已掌握Go编程，但您无需对Raft或其它任何分布式共识算法有任何掌握。

## 分布式共识算法 ##

如果您对Raft等分布式共识算法已经有足够了解，可以跳过本节。

为了避免单点问题，我们希望数据有多个副本且被保存在多个服务器上，当某一台或几台服务器出现当机时，根据副本数和位置可以有机会使得数据依旧在线进而服务继续可用，这也就是大家常说的高可用。存储在多个服务器上的多个副本同时提供了更高的整体读带宽，这对互联网应用普遍具有的高读写比特性也具备实际意义。

以三个副本的数据为例，如果不考虑三个副本是否一致，只要任何一个副本在线，我们就可以认为数据可用。但这样的做法引入了副本间数据不一致的问题，把麻烦推给了应用，目前这种做法已经逐渐基本淘汰。在多数副本在线这一前提下，即三个副本中的至少两个可用时，共识算法可以使得这三个副本在外界看起来始终一致并可用。目前，所有主要互联网公司均开始不同程度使用共识算法来达到上述高可用与副本数据一致。

为了提供这样的数据一致与高可用，同时保证应用开发的方便，共识算法提供了一种称为复制状态机的系统模型。用户的应用被抽象为状态机，对状态机状态的更新由用户提交的称为Proposal的提议来实现。共识算法确保当有多个用户提交不同提议时，那些被多数副本成功收到且持久保存的提议会被采纳（committed），在不同的副本上，它们将被以同样的顺序记录在称为Log的一个有序数据结构中。这些被采纳的提议，又会以上述既定的顺序被逐一应用到用户应用的状态机中以更新状态机的状态。当状态机的多个副本的初始状态相同，且在各个副本上均严格按照Log内的内容逐一更新，那么Log中同一被采纳的提议被执行后，各个状态副本的状态也将是相同的。

增加例子

读操作的一致性需要满足以下两点：
* 当一个写请求以提议的形式被采纳以后，此时通过读操作，必须可以读到这个写请求的结果，或者比它更新的结果。
* 当一个读请求返回了结果后开始下一个新的读请求，该新的读请求必须返回上一次读的结果或比它更新的结果。

共识库最主要功能即实现共识算法并提供编程接口供使用者实现他们的应用状态机，进而方便用户使用共识库的状态机读写功能来操作应用状态机，方便其实现其各项业务逻辑。

下面各节将展开讨论如何使用dragonboat提供的各项便利，方便的构建基于Raft分布式共识算法的应用。

## 术语 ##

Raft组：Raft协议控制下的一个独立的具有多个副本的实体，组内各个副本提供上一节中描述的一致性保证。一个应用可以使用管理一个或者多个Raft组。
集群Cluster：Raft组的别称。
节点Node：Raft组中的一个成员副本。
Leader：Raft协议中定义的扮演Leader角色的节点。每个Raft组应有一个Leader节点，只有当Leader节点确定时才能对该Raft组进行读写。
快照Snapshot：把状态机在某具体时间点上的状态完全保存所得到的数据，可用于快速恢复状态机状态。

## 状态机 ##

状态机是用户应用的核心，它实现用户的业务逻辑，比如当您想构建类似Redis的基于内存的Key-Value数据库，那您的状态机就是这样一个KV数据库。状态机同时也是用户应用与Dragonboat一大交互接口，Dragonboat库通过状态机所实现的IStateMachine或IOnDiskStateMachine接口与之交互，完成状态机状态更新与查询等操作。

### 基于内存的状态机 ###

基于内存的状态机的主要数据通常存放于内存内，这同时决定其总的数据量相对较小，状态机的状态会在每次节点重启后被重置，需要Dragonboat通过已持久化保存的Log或者快照Snapshot给予恢复。它的特点是实现简单、吞吐可达千万次每秒，但需要定期的保存快照Snapshot带来额外的IO开销。较常见的基于内存的状态机的例子是类似Redis的基于内存的Key-Value数据库。

用户需要实现statemachine包中的IStateMachine接口以实现基于内存的状态机。此类基于内存的状态机在每次重启后应确保其初始状态为空，并由Dragonboat负责通过Update与RecoverFromSnapshot两个方法来恢复状态机的状态。请注意，基于内存的状态机的状态在重启后被重置，但没有任何>数据会被丢失，系统会使用持久保存的快照Snapshot和Log的所有状态机历史输入数据重建状态机状态。

### 基于磁盘的状态机 ###

基于磁盘的状态的主要数据保存于磁盘上，因此其总数据量相对较大，状态机的状态始终在磁盘上持久保存，每次节点重启后状态机状态不受影响。Dragonboat依旧需要定期保存快照Snapshot，但此类快照仅包含元数据，创建的开销及小。它的特点是实现较基于内存的状态机稍复杂一些，吞吐受落盘影响较小，但它定期保存快照的额外IO开销极小。

用户需要实现statemachine包中的IOnDiskStateMachine接口以实现基于磁盘的状态机。此类基于磁盘的状态机由用户负责其状态的持久化保存，Dragonboat仅负责在每次重启后打开并启用已保存的状态机。

### 两类状态机的选择 ###

基于内存与基于磁盘的状态机的选择的最重要指标是状态机所管理的总数据大小。在所有状态机数据可以被存放于内存内的时候，建议使用基于内存的状态机，基于磁盘的状态机可以视为是状态机管理数据较大情况下的一种针对额外IO开销的优化。


