// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raft.proto

package raftpb

/*
	Package raftpb contains definition of raft internal structs, states and
	messages that are not visible to typical dragonboat applications. It is
	required when building your customized LogDB and Raft RPC modules. You
	can safely ignore this package when building dragonboat applications.
*/

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MessageType int32

const (
	LocalTick         MessageType = 0
	Election          MessageType = 1
	LeaderHeartbeat   MessageType = 2
	ConfigChangeEvent MessageType = 3
	NoOP              MessageType = 4
	Ping              MessageType = 5
	Pong              MessageType = 6
	Propose           MessageType = 7
	SnapshotStatus    MessageType = 8
	Unreachable       MessageType = 9
	CheckQuorum       MessageType = 10
	BatchedReadIndex  MessageType = 11
	Replicate         MessageType = 12
	ReplicateResp     MessageType = 13
	RequestVote       MessageType = 14
	RequestVoteResp   MessageType = 15
	InstallSnapshot   MessageType = 16
	Heartbeat         MessageType = 17
	HeartbeatResp     MessageType = 18
	ReadIndex         MessageType = 19
	ReadIndexResp     MessageType = 20
	Quiesce           MessageType = 21
	SnapshotReceived  MessageType = 22
	LeaderTransfer    MessageType = 23
	TimeoutNow        MessageType = 24
	RateLimit         MessageType = 25
)

var MessageType_name = map[int32]string{
	0:  "LocalTick",
	1:  "Election",
	2:  "LeaderHeartbeat",
	3:  "ConfigChangeEvent",
	4:  "NoOP",
	5:  "Ping",
	6:  "Pong",
	7:  "Propose",
	8:  "SnapshotStatus",
	9:  "Unreachable",
	10: "CheckQuorum",
	11: "BatchedReadIndex",
	12: "Replicate",
	13: "ReplicateResp",
	14: "RequestVote",
	15: "RequestVoteResp",
	16: "InstallSnapshot",
	17: "Heartbeat",
	18: "HeartbeatResp",
	19: "ReadIndex",
	20: "ReadIndexResp",
	21: "Quiesce",
	22: "SnapshotReceived",
	23: "LeaderTransfer",
	24: "TimeoutNow",
	25: "RateLimit",
}
var MessageType_value = map[string]int32{
	"LocalTick":         0,
	"Election":          1,
	"LeaderHeartbeat":   2,
	"ConfigChangeEvent": 3,
	"NoOP":              4,
	"Ping":              5,
	"Pong":              6,
	"Propose":           7,
	"SnapshotStatus":    8,
	"Unreachable":       9,
	"CheckQuorum":       10,
	"BatchedReadIndex":  11,
	"Replicate":         12,
	"ReplicateResp":     13,
	"RequestVote":       14,
	"RequestVoteResp":   15,
	"InstallSnapshot":   16,
	"Heartbeat":         17,
	"HeartbeatResp":     18,
	"ReadIndex":         19,
	"ReadIndexResp":     20,
	"Quiesce":           21,
	"SnapshotReceived":  22,
	"LeaderTransfer":    23,
	"TimeoutNow":        24,
	"RateLimit":         25,
}

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}
func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (x *MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageType_value, data, "MessageType")
	if err != nil {
		return err
	}
	*x = MessageType(value)
	return nil
}
func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{0}
}

type EntryType int32

const (
	ApplicationEntry  EntryType = 0
	ConfigChangeEntry EntryType = 1
)

var EntryType_name = map[int32]string{
	0: "ApplicationEntry",
	1: "ConfigChangeEntry",
}
var EntryType_value = map[string]int32{
	"ApplicationEntry":  0,
	"ConfigChangeEntry": 1,
}

func (x EntryType) Enum() *EntryType {
	p := new(EntryType)
	*p = x
	return p
}
func (x EntryType) String() string {
	return proto.EnumName(EntryType_name, int32(x))
}
func (x *EntryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntryType_value, data, "EntryType")
	if err != nil {
		return err
	}
	*x = EntryType(value)
	return nil
}
func (EntryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{1}
}

type ConfigChangeType int32

const (
	AddNode     ConfigChangeType = 0
	RemoveNode  ConfigChangeType = 1
	AddObserver ConfigChangeType = 2
)

var ConfigChangeType_name = map[int32]string{
	0: "AddNode",
	1: "RemoveNode",
	2: "AddObserver",
}
var ConfigChangeType_value = map[string]int32{
	"AddNode":     0,
	"RemoveNode":  1,
	"AddObserver": 2,
}

func (x ConfigChangeType) Enum() *ConfigChangeType {
	p := new(ConfigChangeType)
	*p = x
	return p
}
func (x ConfigChangeType) String() string {
	return proto.EnumName(ConfigChangeType_name, int32(x))
}
func (x *ConfigChangeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigChangeType_value, data, "ConfigChangeType")
	if err != nil {
		return err
	}
	*x = ConfigChangeType(value)
	return nil
}
func (ConfigChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{2}
}

type StateMachineType int32

const (
	UnknownStateMachine    StateMachineType = 0
	RegularStateMachine    StateMachineType = 1
	ConcurrentStateMachine StateMachineType = 2
	OnDiskStateMachine     StateMachineType = 3
)

var StateMachineType_name = map[int32]string{
	0: "UnknownStateMachine",
	1: "RegularStateMachine",
	2: "ConcurrentStateMachine",
	3: "OnDiskStateMachine",
}
var StateMachineType_value = map[string]int32{
	"UnknownStateMachine":    0,
	"RegularStateMachine":    1,
	"ConcurrentStateMachine": 2,
	"OnDiskStateMachine":     3,
}

func (x StateMachineType) Enum() *StateMachineType {
	p := new(StateMachineType)
	*p = x
	return p
}
func (x StateMachineType) String() string {
	return proto.EnumName(StateMachineType_name, int32(x))
}
func (x *StateMachineType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StateMachineType_value, data, "StateMachineType")
	if err != nil {
		return err
	}
	*x = StateMachineType(value)
	return nil
}
func (StateMachineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{3}
}

type ChecksumType int32

const (
	CRC32IEEE ChecksumType = 0
	HIGHWAY   ChecksumType = 1
)

var ChecksumType_name = map[int32]string{
	0: "CRC32IEEE",
	1: "HIGHWAY",
}
var ChecksumType_value = map[string]int32{
	"CRC32IEEE": 0,
	"HIGHWAY":   1,
}

func (x ChecksumType) Enum() *ChecksumType {
	p := new(ChecksumType)
	*p = x
	return p
}
func (x ChecksumType) String() string {
	return proto.EnumName(ChecksumType_name, int32(x))
}
func (x *ChecksumType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChecksumType_value, data, "ChecksumType")
	if err != nil {
		return err
	}
	*x = ChecksumType(value)
	return nil
}
func (ChecksumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{4}
}

type Bootstrap struct {
	Addresses map[uint64]string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Join      bool              `protobuf:"varint,2,opt,name=join" json:"join"`
	Type      StateMachineType  `protobuf:"varint,3,opt,name=Type,enum=raftpb.StateMachineType" json:"Type"`
}

func (m *Bootstrap) Reset()         { *m = Bootstrap{} }
func (m *Bootstrap) String() string { return proto.CompactTextString(m) }
func (*Bootstrap) ProtoMessage()    {}
func (*Bootstrap) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{0}
}
func (m *Bootstrap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bootstrap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bootstrap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Bootstrap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bootstrap.Merge(dst, src)
}
func (m *Bootstrap) XXX_Size() int {
	return m.Size()
}
func (m *Bootstrap) XXX_DiscardUnknown() {
	xxx_messageInfo_Bootstrap.DiscardUnknown(m)
}

var xxx_messageInfo_Bootstrap proto.InternalMessageInfo

func (m *Bootstrap) GetAddresses() map[uint64]string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Bootstrap) GetJoin() bool {
	if m != nil {
		return m.Join
	}
	return false
}

func (m *Bootstrap) GetType() StateMachineType {
	if m != nil {
		return m.Type
	}
	return UnknownStateMachine
}

type RaftDataStatus struct {
	Address         string `protobuf:"bytes,1,opt,name=address" json:"address"`
	BinVer          uint32 `protobuf:"varint,2,opt,name=bin_ver,json=binVer" json:"bin_ver"`
	HardHash        uint64 `protobuf:"varint,3,opt,name=hard_hash,json=hardHash" json:"hard_hash"`
	LogdbType       string `protobuf:"bytes,4,opt,name=logdb_type,json=logdbType" json:"logdb_type"`
	Hostname        string `protobuf:"bytes,5,opt,name=hostname" json:"hostname"`
	DeploymentId    uint64 `protobuf:"varint,6,opt,name=deployment_id,json=deploymentId" json:"deployment_id"`
	StepWorkerCount uint64 `protobuf:"varint,7,opt,name=step_worker_count,json=stepWorkerCount" json:"step_worker_count"`
	LogdbShardCount uint64 `protobuf:"varint,8,opt,name=logdb_shard_count,json=logdbShardCount" json:"logdb_shard_count"`
	MaxSessionCount uint64 `protobuf:"varint,9,opt,name=max_session_count,json=maxSessionCount" json:"max_session_count"`
	EntryBatchSize  uint64 `protobuf:"varint,10,opt,name=entry_batch_size,json=entryBatchSize" json:"entry_batch_size"`
}

func (m *RaftDataStatus) Reset()         { *m = RaftDataStatus{} }
func (m *RaftDataStatus) String() string { return proto.CompactTextString(m) }
func (*RaftDataStatus) ProtoMessage()    {}
func (*RaftDataStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{1}
}
func (m *RaftDataStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftDataStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftDataStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RaftDataStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftDataStatus.Merge(dst, src)
}
func (m *RaftDataStatus) XXX_Size() int {
	return m.Size()
}
func (m *RaftDataStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftDataStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RaftDataStatus proto.InternalMessageInfo

func (m *RaftDataStatus) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaftDataStatus) GetBinVer() uint32 {
	if m != nil {
		return m.BinVer
	}
	return 0
}

func (m *RaftDataStatus) GetHardHash() uint64 {
	if m != nil {
		return m.HardHash
	}
	return 0
}

func (m *RaftDataStatus) GetLogdbType() string {
	if m != nil {
		return m.LogdbType
	}
	return ""
}

func (m *RaftDataStatus) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *RaftDataStatus) GetDeploymentId() uint64 {
	if m != nil {
		return m.DeploymentId
	}
	return 0
}

func (m *RaftDataStatus) GetStepWorkerCount() uint64 {
	if m != nil {
		return m.StepWorkerCount
	}
	return 0
}

func (m *RaftDataStatus) GetLogdbShardCount() uint64 {
	if m != nil {
		return m.LogdbShardCount
	}
	return 0
}

func (m *RaftDataStatus) GetMaxSessionCount() uint64 {
	if m != nil {
		return m.MaxSessionCount
	}
	return 0
}

func (m *RaftDataStatus) GetEntryBatchSize() uint64 {
	if m != nil {
		return m.EntryBatchSize
	}
	return 0
}

type State struct {
	Term   uint64 `protobuf:"varint,1,opt,name=term" json:"term"`
	Vote   uint64 `protobuf:"varint,2,opt,name=vote" json:"vote"`
	Commit uint64 `protobuf:"varint,3,opt,name=commit" json:"commit"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto.CompactTextString(m) }
func (*State) ProtoMessage()    {}
func (*State) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{2}
}
func (m *State) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_State.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *State) XXX_Merge(src proto.Message) {
	xxx_messageInfo_State.Merge(dst, src)
}
func (m *State) XXX_Size() int {
	return m.Size()
}
func (m *State) XXX_DiscardUnknown() {
	xxx_messageInfo_State.DiscardUnknown(m)
}

var xxx_messageInfo_State proto.InternalMessageInfo

func (m *State) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *State) GetVote() uint64 {
	if m != nil {
		return m.Vote
	}
	return 0
}

func (m *State) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

type Entry struct {
	Term        uint64    `protobuf:"varint,1,opt,name=Term" json:"Term"`
	Index       uint64    `protobuf:"varint,2,opt,name=Index" json:"Index"`
	Type        EntryType `protobuf:"varint,3,opt,name=Type,enum=raftpb.EntryType" json:"Type"`
	Key         uint64    `protobuf:"varint,4,opt,name=Key" json:"Key"`
	ClientID    uint64    `protobuf:"varint,5,opt,name=ClientID" json:"ClientID"`
	SeriesID    uint64    `protobuf:"varint,6,opt,name=SeriesID" json:"SeriesID"`
	RespondedTo uint64    `protobuf:"varint,7,opt,name=RespondedTo" json:"RespondedTo"`
	Cmd         []byte    `protobuf:"bytes,8,opt,name=Cmd" json:"Cmd"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{3}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(dst, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Entry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Entry) GetType() EntryType {
	if m != nil {
		return m.Type
	}
	return ApplicationEntry
}

func (m *Entry) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Entry) GetClientID() uint64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *Entry) GetSeriesID() uint64 {
	if m != nil {
		return m.SeriesID
	}
	return 0
}

func (m *Entry) GetRespondedTo() uint64 {
	if m != nil {
		return m.RespondedTo
	}
	return 0
}

func (m *Entry) GetCmd() []byte {
	if m != nil {
		return m.Cmd
	}
	return nil
}

type EntryBatch struct {
	Entries []Entry `protobuf:"bytes,1,rep,name=entries" json:"entries"`
}

func (m *EntryBatch) Reset()         { *m = EntryBatch{} }
func (m *EntryBatch) String() string { return proto.CompactTextString(m) }
func (*EntryBatch) ProtoMessage()    {}
func (*EntryBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{4}
}
func (m *EntryBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EntryBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryBatch.Merge(dst, src)
}
func (m *EntryBatch) XXX_Size() int {
	return m.Size()
}
func (m *EntryBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EntryBatch proto.InternalMessageInfo

func (m *EntryBatch) GetEntries() []Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Membership struct {
	ConfigChangeId uint64            `protobuf:"varint,1,opt,name=config_change_id,json=configChangeId" json:"config_change_id"`
	Addresses      map[uint64]string `protobuf:"bytes,2,rep,name=addresses" json:"addresses,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Removed        map[uint64]bool   `protobuf:"bytes,3,rep,name=removed" json:"removed,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Observers      map[uint64]string `protobuf:"bytes,4,rep,name=observers" json:"observers,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Membership) Reset()         { *m = Membership{} }
func (m *Membership) String() string { return proto.CompactTextString(m) }
func (*Membership) ProtoMessage()    {}
func (*Membership) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{5}
}
func (m *Membership) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Membership) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Membership.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Membership) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Membership.Merge(dst, src)
}
func (m *Membership) XXX_Size() int {
	return m.Size()
}
func (m *Membership) XXX_DiscardUnknown() {
	xxx_messageInfo_Membership.DiscardUnknown(m)
}

var xxx_messageInfo_Membership proto.InternalMessageInfo

func (m *Membership) GetConfigChangeId() uint64 {
	if m != nil {
		return m.ConfigChangeId
	}
	return 0
}

func (m *Membership) GetAddresses() map[uint64]string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Membership) GetRemoved() map[uint64]bool {
	if m != nil {
		return m.Removed
	}
	return nil
}

func (m *Membership) GetObservers() map[uint64]string {
	if m != nil {
		return m.Observers
	}
	return nil
}

// field id 1 was used for optional string filename
type SnapshotFile struct {
	Filepath string `protobuf:"bytes,2,opt,name=filepath" json:"filepath"`
	FileSize uint64 `protobuf:"varint,3,opt,name=file_size,json=fileSize" json:"file_size"`
	FileId   uint64 `protobuf:"varint,4,opt,name=file_id,json=fileId" json:"file_id"`
	Metadata []byte `protobuf:"bytes,5,opt,name=metadata" json:"metadata"`
}

func (m *SnapshotFile) Reset()         { *m = SnapshotFile{} }
func (m *SnapshotFile) String() string { return proto.CompactTextString(m) }
func (*SnapshotFile) ProtoMessage()    {}
func (*SnapshotFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{6}
}
func (m *SnapshotFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SnapshotFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotFile.Merge(dst, src)
}
func (m *SnapshotFile) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotFile) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotFile.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotFile proto.InternalMessageInfo

func (m *SnapshotFile) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *SnapshotFile) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *SnapshotFile) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *SnapshotFile) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// field id 1 was used for optional string filename
type Snapshot struct {
	Filepath   string           `protobuf:"bytes,2,opt,name=filepath" json:"filepath"`
	FileSize   uint64           `protobuf:"varint,3,opt,name=file_size,json=fileSize" json:"file_size"`
	Index      uint64           `protobuf:"varint,4,opt,name=index" json:"index"`
	Term       uint64           `protobuf:"varint,5,opt,name=term" json:"term"`
	Membership Membership       `protobuf:"bytes,6,opt,name=membership" json:"membership"`
	Files      []*SnapshotFile  `protobuf:"bytes,7,rep,name=files" json:"files,omitempty"`
	Checksum   []byte           `protobuf:"bytes,8,opt,name=Checksum" json:"Checksum"`
	Dummy      bool             `protobuf:"varint,9,opt,name=Dummy" json:"Dummy"`
	ClusterId  uint64           `protobuf:"varint,10,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	Type       StateMachineType `protobuf:"varint,11,opt,name=type,enum=raftpb.StateMachineType" json:"type"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{7}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(dst, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *Snapshot) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Snapshot) GetMembership() Membership {
	if m != nil {
		return m.Membership
	}
	return Membership{}
}

func (m *Snapshot) GetFiles() []*SnapshotFile {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *Snapshot) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *Snapshot) GetDummy() bool {
	if m != nil {
		return m.Dummy
	}
	return false
}

func (m *Snapshot) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *Snapshot) GetType() StateMachineType {
	if m != nil {
		return m.Type
	}
	return UnknownStateMachine
}

type Message struct {
	Type      MessageType `protobuf:"varint,1,opt,name=type,enum=raftpb.MessageType" json:"type"`
	To        uint64      `protobuf:"varint,2,opt,name=to" json:"to"`
	From      uint64      `protobuf:"varint,3,opt,name=from" json:"from"`
	ClusterId uint64      `protobuf:"varint,4,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	Term      uint64      `protobuf:"varint,5,opt,name=term" json:"term"`
	LogTerm   uint64      `protobuf:"varint,6,opt,name=log_term,json=logTerm" json:"log_term"`
	LogIndex  uint64      `protobuf:"varint,7,opt,name=log_index,json=logIndex" json:"log_index"`
	Commit    uint64      `protobuf:"varint,8,opt,name=commit" json:"commit"`
	Reject    bool        `protobuf:"varint,9,opt,name=reject" json:"reject"`
	Hint      uint64      `protobuf:"varint,10,opt,name=hint" json:"hint"`
	Entries   []Entry     `protobuf:"bytes,11,rep,name=entries" json:"entries"`
	Snapshot  Snapshot    `protobuf:"bytes,12,opt,name=snapshot" json:"snapshot"`
	HintHigh  uint64      `protobuf:"varint,13,opt,name=hint_high,json=hintHigh" json:"hint_high"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{8}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(dst, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return LocalTick
}

func (m *Message) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Message) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Message) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *Message) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Message) GetLogTerm() uint64 {
	if m != nil {
		return m.LogTerm
	}
	return 0
}

func (m *Message) GetLogIndex() uint64 {
	if m != nil {
		return m.LogIndex
	}
	return 0
}

func (m *Message) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *Message) GetReject() bool {
	if m != nil {
		return m.Reject
	}
	return false
}

func (m *Message) GetHint() uint64 {
	if m != nil {
		return m.Hint
	}
	return 0
}

func (m *Message) GetEntries() []Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Message) GetSnapshot() Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return Snapshot{}
}

func (m *Message) GetHintHigh() uint64 {
	if m != nil {
		return m.HintHigh
	}
	return 0
}

type ConfigChange struct {
	ConfigChangeId uint64           `protobuf:"varint,1,opt,name=config_change_id,json=configChangeId" json:"config_change_id"`
	Type           ConfigChangeType `protobuf:"varint,2,opt,name=Type,enum=raftpb.ConfigChangeType" json:"Type"`
	NodeID         uint64           `protobuf:"varint,3,opt,name=NodeID" json:"NodeID"`
	Address        string           `protobuf:"bytes,4,opt,name=Address" json:"Address"`
	Initialize     bool             `protobuf:"varint,5,opt,name=Initialize" json:"Initialize"`
}

func (m *ConfigChange) Reset()         { *m = ConfigChange{} }
func (m *ConfigChange) String() string { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()    {}
func (*ConfigChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{9}
}
func (m *ConfigChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ConfigChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChange.Merge(dst, src)
}
func (m *ConfigChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChange proto.InternalMessageInfo

func (m *ConfigChange) GetConfigChangeId() uint64 {
	if m != nil {
		return m.ConfigChangeId
	}
	return 0
}

func (m *ConfigChange) GetType() ConfigChangeType {
	if m != nil {
		return m.Type
	}
	return AddNode
}

func (m *ConfigChange) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *ConfigChange) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ConfigChange) GetInitialize() bool {
	if m != nil {
		return m.Initialize
	}
	return false
}

type SnapshotHeader struct {
	SessionSize     uint64       `protobuf:"varint,1,opt,name=session_size,json=sessionSize" json:"session_size"`
	DataStoreSize   uint64       `protobuf:"varint,2,opt,name=data_store_size,json=dataStoreSize" json:"data_store_size"`
	UnreliableTime  uint64       `protobuf:"varint,3,opt,name=unreliable_time,json=unreliableTime" json:"unreliable_time"`
	GitVersion      string       `protobuf:"bytes,4,opt,name=git_version,json=gitVersion" json:"git_version"`
	HeaderChecksum  []byte       `protobuf:"bytes,5,opt,name=header_checksum,json=headerChecksum" json:"header_checksum"`
	PayloadChecksum []byte       `protobuf:"bytes,6,opt,name=payload_checksum,json=payloadChecksum" json:"payload_checksum"`
	ChecksumType    ChecksumType `protobuf:"varint,7,opt,name=checksum_type,json=checksumType,enum=raftpb.ChecksumType" json:"checksum_type"`
	Version         uint64       `protobuf:"varint,8,opt,name=version" json:"version"`
}

func (m *SnapshotHeader) Reset()         { *m = SnapshotHeader{} }
func (m *SnapshotHeader) String() string { return proto.CompactTextString(m) }
func (*SnapshotHeader) ProtoMessage()    {}
func (*SnapshotHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{10}
}
func (m *SnapshotHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SnapshotHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotHeader.Merge(dst, src)
}
func (m *SnapshotHeader) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotHeader proto.InternalMessageInfo

func (m *SnapshotHeader) GetSessionSize() uint64 {
	if m != nil {
		return m.SessionSize
	}
	return 0
}

func (m *SnapshotHeader) GetDataStoreSize() uint64 {
	if m != nil {
		return m.DataStoreSize
	}
	return 0
}

func (m *SnapshotHeader) GetUnreliableTime() uint64 {
	if m != nil {
		return m.UnreliableTime
	}
	return 0
}

func (m *SnapshotHeader) GetGitVersion() string {
	if m != nil {
		return m.GitVersion
	}
	return ""
}

func (m *SnapshotHeader) GetHeaderChecksum() []byte {
	if m != nil {
		return m.HeaderChecksum
	}
	return nil
}

func (m *SnapshotHeader) GetPayloadChecksum() []byte {
	if m != nil {
		return m.PayloadChecksum
	}
	return nil
}

func (m *SnapshotHeader) GetChecksumType() ChecksumType {
	if m != nil {
		return m.ChecksumType
	}
	return CRC32IEEE
}

func (m *SnapshotHeader) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// dummy message used by grpc
type Response struct {
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{11}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(dst, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type MessageBatch struct {
	Requests      []Message `protobuf:"bytes,1,rep,name=requests" json:"requests"`
	DeploymentId  uint64    `protobuf:"varint,2,opt,name=deployment_id,json=deploymentId" json:"deployment_id"`
	SourceAddress string    `protobuf:"bytes,3,opt,name=source_address,json=sourceAddress" json:"source_address"`
	BinVer        uint32    `protobuf:"varint,4,opt,name=bin_ver,json=binVer" json:"bin_ver"`
}

func (m *MessageBatch) Reset()         { *m = MessageBatch{} }
func (m *MessageBatch) String() string { return proto.CompactTextString(m) }
func (*MessageBatch) ProtoMessage()    {}
func (*MessageBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{12}
}
func (m *MessageBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MessageBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageBatch.Merge(dst, src)
}
func (m *MessageBatch) XXX_Size() int {
	return m.Size()
}
func (m *MessageBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageBatch.DiscardUnknown(m)
}

var xxx_messageInfo_MessageBatch proto.InternalMessageInfo

func (m *MessageBatch) GetRequests() []Message {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *MessageBatch) GetDeploymentId() uint64 {
	if m != nil {
		return m.DeploymentId
	}
	return 0
}

func (m *MessageBatch) GetSourceAddress() string {
	if m != nil {
		return m.SourceAddress
	}
	return ""
}

func (m *MessageBatch) GetBinVer() uint32 {
	if m != nil {
		return m.BinVer
	}
	return 0
}

// field id 11 was used for optional string filename
type SnapshotChunk struct {
	ClusterId      uint64       `protobuf:"varint,1,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	NodeId         uint64       `protobuf:"varint,2,opt,name=node_id,json=nodeId" json:"node_id"`
	From           uint64       `protobuf:"varint,3,opt,name=from" json:"from"`
	ChunkId        uint64       `protobuf:"varint,4,opt,name=chunk_id,json=chunkId" json:"chunk_id"`
	ChunkSize      uint64       `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	ChunkCount     uint64       `protobuf:"varint,6,opt,name=chunk_count,json=chunkCount" json:"chunk_count"`
	Data           []byte       `protobuf:"bytes,7,opt,name=data" json:"data"`
	Index          uint64       `protobuf:"varint,8,opt,name=index" json:"index"`
	Term           uint64       `protobuf:"varint,9,opt,name=term" json:"term"`
	Membership     Membership   `protobuf:"bytes,10,opt,name=membership" json:"membership"`
	Filepath       string       `protobuf:"bytes,12,opt,name=filepath" json:"filepath"`
	FileSize       uint64       `protobuf:"varint,13,opt,name=file_size,json=fileSize" json:"file_size"`
	DeploymentId   uint64       `protobuf:"varint,14,opt,name=deployment_id,json=deploymentId" json:"deployment_id"`
	FileChunkId    uint64       `protobuf:"varint,15,opt,name=file_chunk_id,json=fileChunkId" json:"file_chunk_id"`
	FileChunkCount uint64       `protobuf:"varint,16,opt,name=file_chunk_count,json=fileChunkCount" json:"file_chunk_count"`
	HasFileInfo    bool         `protobuf:"varint,17,opt,name=has_file_info,json=hasFileInfo" json:"has_file_info"`
	FileInfo       SnapshotFile `protobuf:"bytes,18,opt,name=file_info,json=fileInfo" json:"file_info"`
	BinVer         uint32       `protobuf:"varint,19,opt,name=bin_ver,json=binVer" json:"bin_ver"`
}

func (m *SnapshotChunk) Reset()         { *m = SnapshotChunk{} }
func (m *SnapshotChunk) String() string { return proto.CompactTextString(m) }
func (*SnapshotChunk) ProtoMessage()    {}
func (*SnapshotChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_raft_cf7e7f0cebfcef1e, []int{13}
}
func (m *SnapshotChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SnapshotChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotChunk.Merge(dst, src)
}
func (m *SnapshotChunk) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotChunk.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotChunk proto.InternalMessageInfo

func (m *SnapshotChunk) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *SnapshotChunk) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SnapshotChunk) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SnapshotChunk) GetChunkId() uint64 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

func (m *SnapshotChunk) GetChunkSize() uint64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *SnapshotChunk) GetChunkCount() uint64 {
	if m != nil {
		return m.ChunkCount
	}
	return 0
}

func (m *SnapshotChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SnapshotChunk) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SnapshotChunk) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *SnapshotChunk) GetMembership() Membership {
	if m != nil {
		return m.Membership
	}
	return Membership{}
}

func (m *SnapshotChunk) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *SnapshotChunk) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *SnapshotChunk) GetDeploymentId() uint64 {
	if m != nil {
		return m.DeploymentId
	}
	return 0
}

func (m *SnapshotChunk) GetFileChunkId() uint64 {
	if m != nil {
		return m.FileChunkId
	}
	return 0
}

func (m *SnapshotChunk) GetFileChunkCount() uint64 {
	if m != nil {
		return m.FileChunkCount
	}
	return 0
}

func (m *SnapshotChunk) GetHasFileInfo() bool {
	if m != nil {
		return m.HasFileInfo
	}
	return false
}

func (m *SnapshotChunk) GetFileInfo() SnapshotFile {
	if m != nil {
		return m.FileInfo
	}
	return SnapshotFile{}
}

func (m *SnapshotChunk) GetBinVer() uint32 {
	if m != nil {
		return m.BinVer
	}
	return 0
}

func init() {
	proto.RegisterType((*Bootstrap)(nil), "raftpb.Bootstrap")
	proto.RegisterMapType((map[uint64]string)(nil), "raftpb.Bootstrap.AddressesEntry")
	proto.RegisterType((*RaftDataStatus)(nil), "raftpb.RaftDataStatus")
	proto.RegisterType((*State)(nil), "raftpb.State")
	proto.RegisterType((*Entry)(nil), "raftpb.Entry")
	proto.RegisterType((*EntryBatch)(nil), "raftpb.EntryBatch")
	proto.RegisterType((*Membership)(nil), "raftpb.Membership")
	proto.RegisterMapType((map[uint64]string)(nil), "raftpb.Membership.AddressesEntry")
	proto.RegisterMapType((map[uint64]string)(nil), "raftpb.Membership.ObserversEntry")
	proto.RegisterMapType((map[uint64]bool)(nil), "raftpb.Membership.RemovedEntry")
	proto.RegisterType((*SnapshotFile)(nil), "raftpb.SnapshotFile")
	proto.RegisterType((*Snapshot)(nil), "raftpb.Snapshot")
	proto.RegisterType((*Message)(nil), "raftpb.Message")
	proto.RegisterType((*ConfigChange)(nil), "raftpb.ConfigChange")
	proto.RegisterType((*SnapshotHeader)(nil), "raftpb.SnapshotHeader")
	proto.RegisterType((*Response)(nil), "raftpb.Response")
	proto.RegisterType((*MessageBatch)(nil), "raftpb.MessageBatch")
	proto.RegisterType((*SnapshotChunk)(nil), "raftpb.SnapshotChunk")
	proto.RegisterEnum("raftpb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("raftpb.EntryType", EntryType_name, EntryType_value)
	proto.RegisterEnum("raftpb.ConfigChangeType", ConfigChangeType_name, ConfigChangeType_value)
	proto.RegisterEnum("raftpb.StateMachineType", StateMachineType_name, StateMachineType_value)
	proto.RegisterEnum("raftpb.ChecksumType", ChecksumType_name, ChecksumType_value)
}
func (m *Bootstrap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bootstrap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for k, _ := range m.Addresses {
			dAtA[i] = 0xa
			i++
			v := m.Addresses[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x10
	i++
	if m.Join {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *RaftDataStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftDataStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.BinVer))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.HardHash))
	dAtA[i] = 0x22
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.LogdbType)))
	i += copy(dAtA[i:], m.LogdbType)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Hostname)))
	i += copy(dAtA[i:], m.Hostname)
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DeploymentId))
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.StepWorkerCount))
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.LogdbShardCount))
	dAtA[i] = 0x48
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.MaxSessionCount))
	dAtA[i] = 0x50
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.EntryBatchSize))
	return i, nil
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Vote))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Commit))
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

/*
func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Key))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClientID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.SeriesID))
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.RespondedTo))
	if m.Cmd != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Cmd)))
		i += copy(dAtA[i:], m.Cmd)
	}
	return i, nil
}*/

func (m *EntryBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Membership) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Membership) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ConfigChangeId))
	if len(m.Addresses) > 0 {
		for k, _ := range m.Addresses {
			dAtA[i] = 0x12
			i++
			v := m.Addresses[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Removed) > 0 {
		for k, _ := range m.Removed {
			dAtA[i] = 0x1a
			i++
			v := m.Removed[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + 1
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Observers) > 0 {
		for k, _ := range m.Observers {
			dAtA[i] = 0x22
			i++
			v := m.Observers[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *SnapshotFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Filepath)))
	i += copy(dAtA[i:], m.Filepath)
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileSize))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileId))
	if m.Metadata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	return i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Filepath)))
	i += copy(dAtA[i:], m.Filepath)
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileSize))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x32
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Membership.Size()))
	n1, err := m.Membership.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Checksum != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	dAtA[i] = 0x48
	i++
	if m.Dummy {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x50
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x58
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.To))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.From))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.LogTerm))
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.LogIndex))
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Commit))
	dAtA[i] = 0x48
	i++
	if m.Reject {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x50
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Hint))
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Snapshot.Size()))
	n2, err := m.Snapshot.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x68
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.HintHigh))
	return i, nil
}

func (m *ConfigChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ConfigChangeId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.NodeID))
	dAtA[i] = 0x22
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	dAtA[i] = 0x28
	i++
	if m.Initialize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *SnapshotHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.SessionSize))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DataStoreSize))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.UnreliableTime))
	dAtA[i] = 0x22
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.GitVersion)))
	i += copy(dAtA[i:], m.GitVersion)
	if m.HeaderChecksum != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.HeaderChecksum)))
		i += copy(dAtA[i:], m.HeaderChecksum)
	}
	if m.PayloadChecksum != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.PayloadChecksum)))
		i += copy(dAtA[i:], m.PayloadChecksum)
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChecksumType))
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Version))
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MessageBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DeploymentId))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.SourceAddress)))
	i += copy(dAtA[i:], m.SourceAddress)
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.BinVer))
	return i, nil
}

func (m *SnapshotChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.NodeId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.From))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChunkId))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChunkSize))
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChunkCount))
	if m.Data != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x48
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x52
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Membership.Size()))
	n3, err := m.Membership.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x62
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Filepath)))
	i += copy(dAtA[i:], m.Filepath)
	dAtA[i] = 0x68
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileSize))
	dAtA[i] = 0x70
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DeploymentId))
	dAtA[i] = 0x78
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileChunkId))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileChunkCount))
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	if m.HasFileInfo {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileInfo.Size()))
	n4, err := m.FileInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.BinVer))
	return i, nil
}

func encodeVarintRaft(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Bootstrap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for k, v := range m.Addresses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	n += 2
	n += 1 + sovRaft(uint64(m.Type))
	return n
}

func (m *RaftDataStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.BinVer))
	n += 1 + sovRaft(uint64(m.HardHash))
	l = len(m.LogdbType)
	n += 1 + l + sovRaft(uint64(l))
	l = len(m.Hostname)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.DeploymentId))
	n += 1 + sovRaft(uint64(m.StepWorkerCount))
	n += 1 + sovRaft(uint64(m.LogdbShardCount))
	n += 1 + sovRaft(uint64(m.MaxSessionCount))
	n += 1 + sovRaft(uint64(m.EntryBatchSize))
	return n
}

func (m *State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.Term))
	n += 1 + sovRaft(uint64(m.Vote))
	n += 1 + sovRaft(uint64(m.Commit))
	return n
}

/*
func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.Term))
	n += 1 + sovRaft(uint64(m.Index))
	n += 1 + sovRaft(uint64(m.Type))
	n += 1 + sovRaft(uint64(m.Key))
	n += 1 + sovRaft(uint64(m.ClientID))
	n += 1 + sovRaft(uint64(m.SeriesID))
	n += 1 + sovRaft(uint64(m.RespondedTo))
	if m.Cmd != nil {
		l = len(m.Cmd)
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}*/

func (m *EntryBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	return n
}

func (m *Membership) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.ConfigChangeId))
	if len(m.Addresses) > 0 {
		for k, v := range m.Addresses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	if len(m.Removed) > 0 {
		for k, v := range m.Removed {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	if len(m.Observers) > 0 {
		for k, v := range m.Observers {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SnapshotFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filepath)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.FileSize))
	n += 1 + sovRaft(uint64(m.FileId))
	if m.Metadata != nil {
		l = len(m.Metadata)
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filepath)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.FileSize))
	n += 1 + sovRaft(uint64(m.Index))
	n += 1 + sovRaft(uint64(m.Term))
	l = m.Membership.Size()
	n += 1 + l + sovRaft(uint64(l))
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.Checksum != nil {
		l = len(m.Checksum)
		n += 1 + l + sovRaft(uint64(l))
	}
	n += 2
	n += 1 + sovRaft(uint64(m.ClusterId))
	n += 1 + sovRaft(uint64(m.Type))
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.Type))
	n += 1 + sovRaft(uint64(m.To))
	n += 1 + sovRaft(uint64(m.From))
	n += 1 + sovRaft(uint64(m.ClusterId))
	n += 1 + sovRaft(uint64(m.Term))
	n += 1 + sovRaft(uint64(m.LogTerm))
	n += 1 + sovRaft(uint64(m.LogIndex))
	n += 1 + sovRaft(uint64(m.Commit))
	n += 2
	n += 1 + sovRaft(uint64(m.Hint))
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	l = m.Snapshot.Size()
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.HintHigh))
	return n
}

func (m *ConfigChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.ConfigChangeId))
	n += 1 + sovRaft(uint64(m.Type))
	n += 1 + sovRaft(uint64(m.NodeID))
	l = len(m.Address)
	n += 1 + l + sovRaft(uint64(l))
	n += 2
	return n
}

func (m *SnapshotHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.SessionSize))
	n += 1 + sovRaft(uint64(m.DataStoreSize))
	n += 1 + sovRaft(uint64(m.UnreliableTime))
	l = len(m.GitVersion)
	n += 1 + l + sovRaft(uint64(l))
	if m.HeaderChecksum != nil {
		l = len(m.HeaderChecksum)
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.PayloadChecksum != nil {
		l = len(m.PayloadChecksum)
		n += 1 + l + sovRaft(uint64(l))
	}
	n += 1 + sovRaft(uint64(m.ChecksumType))
	n += 1 + sovRaft(uint64(m.Version))
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MessageBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	n += 1 + sovRaft(uint64(m.DeploymentId))
	l = len(m.SourceAddress)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.BinVer))
	return n
}

func (m *SnapshotChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.ClusterId))
	n += 1 + sovRaft(uint64(m.NodeId))
	n += 1 + sovRaft(uint64(m.From))
	n += 1 + sovRaft(uint64(m.ChunkId))
	n += 1 + sovRaft(uint64(m.ChunkSize))
	n += 1 + sovRaft(uint64(m.ChunkCount))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovRaft(uint64(l))
	}
	n += 1 + sovRaft(uint64(m.Index))
	n += 1 + sovRaft(uint64(m.Term))
	l = m.Membership.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = len(m.Filepath)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.FileSize))
	n += 1 + sovRaft(uint64(m.DeploymentId))
	n += 1 + sovRaft(uint64(m.FileChunkId))
	n += 2 + sovRaft(uint64(m.FileChunkCount))
	n += 3
	l = m.FileInfo.Size()
	n += 2 + l + sovRaft(uint64(l))
	n += 2 + sovRaft(uint64(m.BinVer))
	return n
}

func sovRaft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Bootstrap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bootstrap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bootstrap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addresses == nil {
				m.Addresses = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Addresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Join = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StateMachineType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftDataStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftDataStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftDataStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinVer", wireType)
			}
			m.BinVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinVer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardHash", wireType)
			}
			m.HardHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogdbType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogdbType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepWorkerCount", wireType)
			}
			m.StepWorkerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepWorkerCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogdbShardCount", wireType)
			}
			m.LogdbShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogdbShardCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessionCount", wireType)
			}
			m.MaxSessionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessionCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryBatchSize", wireType)
			}
			m.EntryBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryBatchSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

/*
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (EntryType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesID", wireType)
			}
			m.SeriesID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespondedTo", wireType)
			}
			m.RespondedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespondedTo |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd[:0], dAtA[iNdEx:postIndex]...)
			if m.Cmd == nil {
				m.Cmd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}*/

func (m *EntryBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Membership) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Membership: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Membership: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeId", wireType)
			}
			m.ConfigChangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigChangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addresses == nil {
				m.Addresses = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Addresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Removed == nil {
				m.Removed = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Removed[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Observers == nil {
				m.Observers = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Observers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Membership.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &SnapshotFile{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum[:0], dAtA[iNdEx:postIndex]...)
			if m.Checksum == nil {
				m.Checksum = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dummy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dummy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StateMachineType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

/*
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MessageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTerm", wireType)
			}
			m.LogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			m.Hint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hint |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HintHigh", wireType)
			}
			m.HintHigh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HintHigh |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}*/
func (m *ConfigChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeId", wireType)
			}
			m.ConfigChangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigChangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ConfigChangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initialize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Initialize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionSize", wireType)
			}
			m.SessionSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStoreSize", wireType)
			}
			m.DataStoreSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStoreSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreliableTime", wireType)
			}
			m.UnreliableTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreliableTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderChecksum = append(m.HeaderChecksum[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderChecksum == nil {
				m.HeaderChecksum = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadChecksum = append(m.PayloadChecksum[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadChecksum == nil {
				m.PayloadChecksum = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumType", wireType)
			}
			m.ChecksumType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChecksumType |= (ChecksumType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

/*
func (m *MessageBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, Message{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinVer", wireType)
			}
			m.BinVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinVer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}*/
func (m *SnapshotChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkId", wireType)
			}
			m.ChunkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkCount", wireType)
			}
			m.ChunkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Membership.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunkId", wireType)
			}
			m.FileChunkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileChunkId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunkCount", wireType)
			}
			m.FileChunkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileChunkCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFileInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFileInfo = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinVer", wireType)
			}
			m.BinVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinVer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRaft(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRaft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("raft.proto", fileDescriptor_raft_cf7e7f0cebfcef1e) }

var fileDescriptor_raft_cf7e7f0cebfcef1e = []byte{
	// 1909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4d, 0x73, 0x1b, 0xc7,
	0xd1, 0xc6, 0xe2, 0x83, 0x00, 0x1a, 0x1f, 0x5c, 0x8e, 0x64, 0x19, 0x2f, 0x4b, 0xa6, 0x28, 0xbc,
	0x71, 0xc2, 0xd0, 0x11, 0x95, 0x30, 0x87, 0x28, 0x49, 0x55, 0x1c, 0x0a, 0xa4, 0x43, 0x94, 0xf5,
	0x65, 0x90, 0x96, 0xcb, 0x27, 0xd4, 0x60, 0x77, 0x88, 0x1d, 0x73, 0x77, 0x07, 0xd9, 0x19, 0x50,
	0xa2, 0x8f, 0x39, 0xe4, 0x9c, 0x43, 0x7e, 0x45, 0x4e, 0x39, 0xe6, 0x07, 0xa4, 0x2a, 0x3e, 0xea,
	0x92, 0x54, 0x4e, 0xa9, 0x44, 0xfa, 0x1f, 0xa9, 0x54, 0xcf, 0xec, 0x2e, 0x66, 0x01, 0x32, 0xb2,
	0x53, 0xbe, 0x61, 0x9f, 0xee, 0x9e, 0xee, 0xe9, 0xee, 0x79, 0xba, 0x01, 0x90, 0xd0, 0x33, 0xb5,
	0x37, 0x4b, 0x84, 0x12, 0x64, 0x0d, 0x7f, 0xcf, 0x26, 0x9b, 0xf7, 0xa6, 0x5c, 0x05, 0xf3, 0xc9,
	0x9e, 0x27, 0xa2, 0xfb, 0x53, 0x31, 0x15, 0xf7, 0xb5, 0x78, 0x32, 0x3f, 0xd3, 0x5f, 0xfa, 0x43,
	0xff, 0x32, 0x66, 0xfd, 0x37, 0x0e, 0x34, 0x1f, 0x0a, 0xa1, 0xa4, 0x4a, 0xe8, 0x8c, 0xfc, 0x02,
	0x9a, 0xd4, 0xf7, 0x13, 0x26, 0x25, 0x93, 0x3d, 0x67, 0xbb, 0xb2, 0xd3, 0xda, 0xdf, 0xde, 0x33,
	0x07, 0xef, 0xe5, 0x5a, 0x7b, 0x07, 0x99, 0xca, 0x51, 0xac, 0x92, 0xcb, 0xd1, 0xc2, 0x84, 0xf4,
	0xa0, 0xfa, 0x85, 0xe0, 0x71, 0xaf, 0xbc, 0xed, 0xec, 0x34, 0x1e, 0x56, 0xbf, 0xfa, 0xc7, 0x9d,
	0xd2, 0x48, 0x23, 0x64, 0x1f, 0xaa, 0xa7, 0x97, 0x33, 0xd6, 0xab, 0x6c, 0x3b, 0x3b, 0xdd, 0xfd,
	0x5e, 0x76, 0xe8, 0x89, 0xa2, 0x8a, 0x3d, 0xa6, 0x5e, 0xc0, 0x63, 0x86, 0xf2, 0xcc, 0x06, 0x7f,
	0x6f, 0x1e, 0x43, 0xb7, 0xe8, 0x8a, 0xdc, 0x82, 0xca, 0x39, 0xbb, 0xec, 0x39, 0xdb, 0xce, 0x4e,
	0x35, 0x55, 0x45, 0x80, 0x6c, 0x42, 0xed, 0x82, 0x86, 0x73, 0xa6, 0x1d, 0x37, 0x53, 0x89, 0x81,
	0x7e, 0x56, 0x7e, 0xe0, 0xf4, 0xff, 0x50, 0x81, 0xee, 0x88, 0x9e, 0xa9, 0x43, 0xaa, 0x28, 0xba,
	0x9c, 0x4b, 0xb2, 0x05, 0xf5, 0x34, 0x6e, 0x7d, 0x5c, 0x66, 0x94, 0x81, 0xe4, 0x3d, 0xa8, 0x4f,
	0x78, 0x3c, 0xbe, 0x60, 0x89, 0x3e, 0xb4, 0x93, 0xca, 0xd7, 0x26, 0x3c, 0x7e, 0xce, 0x12, 0x72,
	0x17, 0x9a, 0x01, 0x4d, 0xfc, 0x71, 0x40, 0x65, 0xa0, 0x2f, 0x95, 0xc5, 0xd3, 0x40, 0xf8, 0x98,
	0xca, 0x80, 0xfc, 0x3f, 0x40, 0x28, 0xa6, 0xfe, 0x64, 0xac, 0xf0, 0xe2, 0x55, 0xcb, 0x49, 0x53,
	0xe3, 0x78, 0x47, 0xb2, 0x0d, 0x8d, 0x40, 0x48, 0x15, 0xd3, 0x88, 0xf5, 0x6a, 0x96, 0x4a, 0x8e,
	0x92, 0xef, 0x43, 0xc7, 0x67, 0xb3, 0x50, 0x5c, 0x46, 0x2c, 0x56, 0x63, 0xee, 0xf7, 0xd6, 0x2c,
	0x6f, 0xed, 0x85, 0x68, 0xe8, 0x93, 0x1f, 0xc2, 0x86, 0x54, 0x6c, 0x36, 0x7e, 0x21, 0x92, 0x73,
	0x96, 0x8c, 0x3d, 0x31, 0x8f, 0x55, 0xaf, 0x6e, 0xa9, 0xaf, 0xa3, 0xf8, 0x33, 0x2d, 0x1d, 0xa0,
	0x10, 0x2d, 0x4c, 0x8c, 0x52, 0xdf, 0xc6, 0x58, 0x34, 0x6c, 0x0b, 0x2d, 0x3e, 0x41, 0x69, 0x6e,
	0x11, 0xd1, 0x97, 0x63, 0xc9, 0xa4, 0xe4, 0x22, 0x4e, 0x2d, 0x9a, 0xb6, 0x45, 0x44, 0x5f, 0x9e,
	0x18, 0xa9, 0xb1, 0xd8, 0x03, 0x97, 0x61, 0xf5, 0xc6, 0x13, 0xaa, 0xbc, 0x60, 0x2c, 0xf9, 0x97,
	0xac, 0x07, 0x96, 0x41, 0x57, 0x4b, 0x1f, 0xa2, 0xf0, 0x84, 0x7f, 0xc9, 0xfa, 0x9f, 0x43, 0x4d,
	0xb7, 0x05, 0x76, 0x93, 0x62, 0x49, 0x54, 0x28, 0xb7, 0x46, 0x50, 0x72, 0x21, 0x94, 0x29, 0x77,
	0x2e, 0x41, 0x84, 0xdc, 0x86, 0x35, 0x4f, 0x44, 0x11, 0x57, 0x85, 0xa2, 0xa4, 0x58, 0xff, 0xb7,
	0x65, 0xa8, 0x99, 0x4e, 0xea, 0x41, 0xf5, 0x74, 0xe5, 0x6c, 0x44, 0xb0, 0x97, 0x86, 0xb1, 0xcf,
	0x5e, 0x16, 0x0e, 0x37, 0x10, 0xf9, 0xa0, 0xd0, 0xc5, 0x1b, 0x59, 0x17, 0xeb, 0x23, 0x97, 0xdb,
	0x17, 0x9b, 0xf5, 0x63, 0x76, 0xa9, 0x0b, 0x9f, 0x37, 0xeb, 0xc7, 0xec, 0x12, 0x4b, 0x3e, 0x08,
	0x39, 0x56, 0xec, 0x50, 0x97, 0x3c, 0xef, 0x9c, 0x0c, 0x45, 0x8d, 0x13, 0x96, 0x70, 0x26, 0x87,
	0x87, 0x85, 0x6a, 0xe7, 0x28, 0xf9, 0x2e, 0xb4, 0x46, 0x4c, 0xce, 0x44, 0xec, 0x33, 0xff, 0x54,
	0x14, 0x6a, 0x6c, 0x0b, 0x30, 0x86, 0x41, 0xe4, 0xeb, 0x8a, 0xb6, 0xb3, 0x18, 0x06, 0x91, 0xdf,
	0xff, 0x39, 0xc0, 0x51, 0x9e, 0x75, 0x72, 0x0f, 0xea, 0x58, 0x03, 0x9e, 0x3f, 0xfa, 0x4e, 0xe1,
	0x66, 0xd9, 0xd3, 0x48, 0x75, 0xfa, 0x7f, 0xad, 0x00, 0x3c, 0x66, 0xd1, 0x84, 0x25, 0x32, 0xe0,
	0x33, 0xac, 0xaf, 0x27, 0xe2, 0x33, 0x3e, 0x1d, 0x7b, 0x01, 0x8d, 0xa7, 0x0c, 0x7b, 0xd4, 0x4e,
	0x6b, 0xd7, 0x48, 0x07, 0x5a, 0x38, 0xf4, 0xc9, 0x87, 0x36, 0xc9, 0x94, 0xb5, 0xbf, 0xbb, 0x99,
	0xbf, 0xc5, 0xb1, 0xff, 0x85, 0x65, 0x7e, 0x0a, 0xf5, 0x84, 0x45, 0xe2, 0x82, 0xf9, 0xbd, 0x8a,
	0x36, 0xbf, 0x73, 0x85, 0xf9, 0xc8, 0x68, 0x18, 0xe3, 0x4c, 0x1f, 0x7d, 0x8b, 0x89, 0x64, 0xc9,
	0x05, 0x4b, 0x64, 0xaf, 0x7a, 0xad, 0xef, 0xa7, 0x99, 0x4e, 0xea, 0x3b, 0xb7, 0xf9, 0xf6, 0x38,
	0x69, 0xf3, 0x23, 0x68, 0xdb, 0x31, 0x7e, 0xbd, 0x73, 0x1a, 0xab, 0xe7, 0x1c, 0x43, 0xb7, 0x18,
	0xee, 0xff, 0xcc, 0x92, 0xbf, 0x77, 0xa0, 0x7d, 0x12, 0xd3, 0x99, 0x0c, 0x84, 0xfa, 0x88, 0x87,
	0x9a, 0x9c, 0xce, 0x78, 0xc8, 0x66, 0x54, 0x05, 0x05, 0x9b, 0x1c, 0x45, 0x1a, 0xc4, 0xdf, 0xe6,
	0x51, 0x17, 0x68, 0x10, 0x61, 0x7c, 0xce, 0x48, 0xa4, 0x5a, 0x85, 0xfb, 0x85, 0xa7, 0xb0, 0x86,
	0xe0, 0xd0, 0x47, 0x1f, 0x11, 0x53, 0xd4, 0xa7, 0x8a, 0xea, 0xd7, 0x90, 0xb5, 0x69, 0x8e, 0xf6,
	0x7f, 0x53, 0x81, 0x46, 0x16, 0xd6, 0xb7, 0x13, 0xd2, 0x26, 0xd4, 0xb8, 0x7e, 0xe2, 0x76, 0x40,
	0x06, 0xca, 0x49, 0xa7, 0xb6, 0x42, 0x3a, 0x0f, 0x00, 0xa2, 0xbc, 0x45, 0xf4, 0xbb, 0x6c, 0xed,
	0x93, 0xd5, 0xe6, 0x49, 0x6d, 0x2c, 0x5d, 0xb2, 0x0b, 0x35, 0xf4, 0x2d, 0x7b, 0x75, 0xdd, 0x71,
	0x37, 0xf3, 0xe9, 0x67, 0x25, 0x7b, 0x64, 0x54, 0x34, 0x3b, 0x04, 0xcc, 0x3b, 0x97, 0xf3, 0xa8,
	0xf0, 0x6c, 0x73, 0x14, 0xa3, 0x3f, 0x9c, 0x47, 0xd1, 0xa5, 0x66, 0xdd, 0xbc, 0x21, 0x34, 0x84,
	0x33, 0xc7, 0x0b, 0xe7, 0x52, 0xb1, 0x04, 0xf3, 0x6d, 0xb3, 0x6c, 0x33, 0xc5, 0x87, 0x3e, 0xce,
	0x62, 0x3d, 0x92, 0x5a, 0x5f, 0x6f, 0x16, 0xa3, 0x6e, 0xff, 0x2f, 0x15, 0xa8, 0x3f, 0x66, 0x52,
	0xd2, 0x29, 0x23, 0xf7, 0x52, 0x7b, 0x47, 0xdb, 0xdf, 0x58, 0xa4, 0x40, 0x8b, 0x97, 0x4d, 0xc9,
	0x4d, 0x28, 0x2b, 0x51, 0x60, 0xd3, 0xb2, 0x12, 0x98, 0xe7, 0xb3, 0x44, 0x44, 0x85, 0x0a, 0x69,
	0x64, 0xe9, 0x0e, 0xd5, 0xab, 0xef, 0x70, 0x7d, 0x99, 0xee, 0x40, 0x23, 0x14, 0xd3, 0xb1, 0x96,
	0xda, 0xe4, 0x59, 0x0f, 0xc5, 0x54, 0x13, 0xfc, 0x5d, 0xc0, 0xf9, 0x3b, 0x36, 0x1d, 0x60, 0x33,
	0x27, 0xda, 0x19, 0x9e, 0x5f, 0x4c, 0x91, 0xc6, 0xea, 0x14, 0x41, 0x69, 0xc2, 0xbe, 0x60, 0x9e,
	0x2a, 0x54, 0x20, 0xc5, 0x30, 0xb2, 0x80, 0xc7, 0xaa, 0x90, 0x7c, 0x8d, 0xd8, 0x34, 0xdb, 0x7a,
	0x3b, 0xcd, 0x92, 0x7d, 0x68, 0xc8, 0xb4, 0x41, 0x7a, 0x6d, 0xdd, 0x6d, 0xee, 0x72, 0xe3, 0x64,
	0x81, 0x67, 0x7a, 0x7a, 0x2d, 0xe1, 0xb1, 0x1a, 0x07, 0x7c, 0x1a, 0xf4, 0x3a, 0x85, 0xb5, 0x84,
	0xc7, 0xea, 0x98, 0x4f, 0x83, 0xfe, 0xdf, 0x1c, 0x68, 0x0f, 0x2c, 0x46, 0xfe, 0xc6, 0xfc, 0x9d,
	0xad, 0x72, 0xe5, 0x62, 0xfb, 0xd8, 0x67, 0xae, 0xcc, 0xc2, 0xdb, 0xb0, 0xf6, 0x44, 0xf8, 0x6c,
	0x78, 0x58, 0x1c, 0xcb, 0x06, 0xc3, 0x5d, 0x2c, 0x25, 0xd5, 0xc2, 0x9a, 0x94, 0x81, 0xe4, 0x3b,
	0x00, 0xc3, 0x98, 0x2b, 0x4e, 0x43, 0x7c, 0xd3, 0x35, 0x2b, 0xe9, 0x16, 0xde, 0xff, 0x77, 0x19,
	0xba, 0x59, 0x62, 0x8e, 0x19, 0xf5, 0x59, 0x42, 0xbe, 0x07, 0xed, 0x6c, 0x51, 0xd1, 0x74, 0x60,
	0x5f, 0xab, 0x95, 0x4a, 0x34, 0x23, 0xfc, 0x00, 0xd6, 0x91, 0x6b, 0xc6, 0x52, 0x89, 0x24, 0xa5,
	0x0e, 0xbb, 0x61, 0x3b, 0xbe, 0x5e, 0x1c, 0x45, 0x62, 0xf8, 0xe3, 0x1e, 0xac, 0xcf, 0xe3, 0x84,
	0x85, 0x9c, 0x4e, 0x42, 0x36, 0x56, 0x3c, 0x2a, 0x12, 0x4d, 0x77, 0x21, 0x3c, 0xe5, 0x11, 0x23,
	0xef, 0x43, 0x6b, 0xca, 0x15, 0xae, 0x92, 0xe8, 0xaf, 0x70, 0x45, 0x98, 0x72, 0xf5, 0xdc, 0xe0,
	0x78, 0x6a, 0xa0, 0xc3, 0x1e, 0x7b, 0x19, 0x01, 0xd8, 0x84, 0xd8, 0x35, 0xc2, 0x9c, 0x06, 0xee,
	0x83, 0x3b, 0xa3, 0x97, 0xa1, 0xa0, 0xfe, 0x42, 0x7f, 0xcd, 0xd2, 0x5f, 0x4f, 0xa5, 0xb9, 0xc1,
	0x87, 0xd0, 0xc9, 0x14, 0xcd, 0x4a, 0x5a, 0xd7, 0x05, 0xcc, 0xd9, 0x28, 0x53, 0xb4, 0x8a, 0xd7,
	0xf6, 0x2c, 0x0c, 0xcb, 0x94, 0xdd, 0xc1, 0x7e, 0x16, 0x19, 0xd8, 0x07, 0x68, 0x98, 0xdd, 0x43,
	0xb2, 0xfe, 0x9f, 0x1c, 0x68, 0xa7, 0x84, 0x60, 0x76, 0x8c, 0x1f, 0x41, 0x23, 0x61, 0xbf, 0x9e,
	0x33, 0xa9, 0xb2, 0x25, 0x63, 0x7d, 0x89, 0x38, 0xb2, 0x4e, 0xcd, 0xd4, 0x56, 0x37, 0xdf, 0xf2,
	0xb5, 0x9b, 0xef, 0x07, 0xd0, 0x95, 0x62, 0x9e, 0x78, 0x6c, 0x9c, 0x2d, 0xf5, 0x15, 0x2b, 0xcb,
	0x1d, 0x23, 0x3b, 0x58, 0x5d, 0xed, 0xab, 0xab, 0xab, 0x7d, 0xff, 0x8f, 0x35, 0xe8, 0x64, 0x7d,
	0x34, 0x08, 0xe6, 0xf1, 0xf9, 0x12, 0x23, 0x39, 0x57, 0x33, 0xd2, 0x7b, 0x50, 0x8f, 0x85, 0xcf,
	0x96, 0xe3, 0x5c, 0x43, 0xd0, 0x10, 0xd6, 0x35, 0x7c, 0x77, 0x07, 0x1a, 0x1e, 0xba, 0x59, 0x66,
	0xbb, 0xba, 0x46, 0x87, 0xbe, 0x76, 0xaf, 0x15, 0x64, 0xd6, 0xfe, 0x0b, 0xf7, 0x88, 0xeb, 0x9e,
	0x7c, 0x1f, 0x5a, 0x46, 0xc9, 0x6c, 0xe4, 0x36, 0xf3, 0x19, 0x6b, 0xb3, 0x8c, 0xf7, 0xa0, 0xaa,
	0x47, 0x6d, 0xdd, 0xea, 0x14, 0x8d, 0x2c, 0x86, 0x62, 0xe3, 0xfa, 0xa1, 0xd8, 0x7c, 0xcb, 0x50,
	0x84, 0x6f, 0x30, 0x14, 0xed, 0x49, 0xde, 0x7e, 0xfb, 0x24, 0xef, 0x5c, 0x39, 0xc9, 0x57, 0x5a,
	0xa4, 0x7b, 0x6d, 0x8b, 0xec, 0x40, 0x47, 0x9f, 0x96, 0xe7, 0x7a, 0xdd, 0x26, 0x03, 0x14, 0x0d,
	0xd2, 0x7c, 0xef, 0x81, 0x6b, 0x69, 0x9a, 0x7c, 0xba, 0xf6, 0xfb, 0xce, 0x95, 0x4d, 0x4e, 0x77,
	0xa0, 0x13, 0x50, 0x39, 0x36, 0x5b, 0x4e, 0x7c, 0x26, 0x7a, 0x1b, 0x16, 0x43, 0xb5, 0x02, 0x2a,
	0x71, 0xbe, 0x0f, 0xe3, 0x33, 0x41, 0x7e, 0x92, 0xde, 0x48, 0x6b, 0x11, 0x9d, 0xac, 0x2b, 0x97,
	0x01, 0xfb, 0x9e, 0xda, 0xd0, 0x6a, 0xd9, 0x1b, 0xab, 0x2d, 0xbb, 0xfb, 0xe7, 0x0a, 0xb4, 0xac,
	0xf1, 0x4b, 0x3a, 0xd0, 0x7c, 0x24, 0x3c, 0x1a, 0x9e, 0x72, 0xef, 0xdc, 0x2d, 0x91, 0x36, 0x34,
	0x8e, 0x42, 0xe6, 0x29, 0x2e, 0x62, 0xd7, 0x21, 0x37, 0x60, 0xfd, 0x91, 0xa6, 0x92, 0x63, 0x46,
	0x13, 0x35, 0x61, 0x54, 0xb9, 0x65, 0xf2, 0x0e, 0x6c, 0xd8, 0x04, 0x7e, 0x74, 0xc1, 0x62, 0xe5,
	0x56, 0x48, 0x03, 0xaa, 0x4f, 0xc4, 0xd3, 0x67, 0x6e, 0x15, 0x7f, 0x3d, 0xe3, 0xf1, 0xd4, 0xad,
	0xe9, 0x5f, 0x22, 0x9e, 0xba, 0x6b, 0xa4, 0x05, 0xf5, 0x67, 0x89, 0x98, 0x09, 0xc9, 0xdc, 0x3a,
	0x21, 0x0b, 0xf6, 0x35, 0x7f, 0xb1, 0xdd, 0x06, 0x59, 0x87, 0xd6, 0xa7, 0x71, 0xc2, 0xa8, 0x17,
	0x20, 0x19, 0xba, 0x4d, 0x04, 0x34, 0xcd, 0x7c, 0x32, 0x17, 0xc9, 0x3c, 0x72, 0x81, 0xdc, 0x04,
	0x57, 0xf3, 0x03, 0xf3, 0x47, 0x8c, 0xfa, 0x7a, 0xfa, 0xba, 0x2d, 0x8c, 0x7f, 0xc4, 0x66, 0x21,
	0xf7, 0xa8, 0x62, 0x6e, 0x9b, 0x6c, 0x40, 0x27, 0xff, 0x44, 0x86, 0x71, 0x3b, 0x78, 0xd0, 0xc8,
	0xf0, 0xc4, 0x73, 0xa1, 0x98, 0xdb, 0xc5, 0x5b, 0x59, 0x80, 0xd6, 0x5a, 0x47, 0x70, 0x18, 0x4b,
	0x45, 0xc3, 0x30, 0x0b, 0xcd, 0x75, 0xf1, 0xf0, 0xc5, 0xcd, 0x37, 0xf0, 0xf0, 0xfc, 0x53, 0x9b,
	0x11, 0xe3, 0x3e, 0x8b, 0xe6, 0x86, 0x71, 0x9f, 0x7e, 0x6a, 0x8d, 0x9b, 0x78, 0xf3, 0x4f, 0xe6,
	0x9c, 0x49, 0x8f, 0xb9, 0xef, 0xe0, 0x1d, 0xb2, 0xe3, 0x47, 0xcc, 0x63, 0xfc, 0x82, 0xf9, 0xee,
	0x2d, 0xcc, 0x87, 0x49, 0xf3, 0x69, 0x42, 0x63, 0x79, 0xc6, 0x12, 0xf7, 0x5d, 0xd2, 0x05, 0xc0,
	0x89, 0x20, 0xe6, 0xea, 0x89, 0x78, 0xe1, 0xf6, 0xb4, 0x23, 0xaa, 0xd8, 0x23, 0x1e, 0x71, 0xe5,
	0xfe, 0xdf, 0xee, 0x03, 0x68, 0xe6, 0x7f, 0x25, 0xf1, 0xd4, 0x83, 0x99, 0xb9, 0x34, 0x17, 0xb1,
	0xc6, 0xdd, 0xd2, 0x4a, 0x9d, 0x34, 0xec, 0xec, 0xfe, 0x12, 0xdc, 0xe5, 0xf9, 0x8b, 0x31, 0x1e,
	0xf8, 0x3e, 0x8e, 0x58, 0xb7, 0x84, 0x9e, 0xcd, 0xbf, 0x0d, 0xfd, 0xed, 0x60, 0xfe, 0x0e, 0x7c,
	0x3f, 0xfb, 0xe3, 0xe0, 0x96, 0x77, 0x5f, 0x82, 0xbb, 0xbc, 0x00, 0x92, 0x77, 0xe1, 0xc6, 0xa7,
	0xf1, 0x79, 0x2c, 0x5e, 0xc4, 0xb6, 0xc8, 0x2d, 0xa1, 0x60, 0xc4, 0xa6, 0xf3, 0x90, 0x26, 0x05,
	0x81, 0x43, 0x36, 0xe1, 0xd6, 0x40, 0xc4, 0xde, 0x3c, 0x49, 0x58, 0xac, 0x0a, 0xb2, 0x32, 0xb9,
	0x05, 0xe4, 0x69, 0x7c, 0xc8, 0xe5, 0x79, 0x01, 0xaf, 0xec, 0xee, 0x42, 0xdb, 0x1e, 0x3d, 0x98,
	0x94, 0xc1, 0x68, 0xf0, 0xe3, 0xfd, 0xe1, 0xd1, 0xd1, 0x91, 0x5b, 0xc2, 0x6b, 0x1c, 0x0f, 0x7f,
	0x75, 0xfc, 0xd9, 0xc1, 0xe7, 0xae, 0xf3, 0xf0, 0xf6, 0xab, 0x7f, 0x6d, 0x95, 0xbe, 0x7a, 0xbd,
	0xe5, 0xbc, 0x7a, 0xbd, 0xe5, 0xfc, 0xf3, 0xf5, 0x96, 0xf3, 0xbb, 0x37, 0x5b, 0xa5, 0x57, 0x6f,
	0xb6, 0x4a, 0x7f, 0x7f, 0xb3, 0x55, 0xfa, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x20, 0x62, 0x5d,
	0xb3, 0x10, 0x13, 0x00, 0x00,
}
